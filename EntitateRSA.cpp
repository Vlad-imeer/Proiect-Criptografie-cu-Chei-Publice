#include "EntitateRSA.h"

unordered_set<long double> EntitateRSA::_chei_private = {};

// „
// This compliant solution uses std::random_device to generate a random value for seeding the Mersenne Twister engine object.
// The values generated by std::random_device are nondeterministic random numbers when possible, relying on random number generation devices, such as /dev/random.
// When such a device is not available, std::random_device may employ a random number engine; however, the initial value generated should have sufficient randomness to serve as a seed value.
// ”
// Sursă: https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC51-CPP.+Ensure+your+random+number+generator+is+properly+seeded
random_device EntitateRSA::_generator_seed = {};
mt19937 EntitateRSA::_generator_numere_aleatorii(EntitateRSA::_generator_seed());

EntitateRSA::EntitateRSA() : _cheie_privata(0), _cheie_publica(0), _nume(EntitateRSA::_nedefinit)
{
}

EntitateRSA::EntitateRSA(const string& p_nume) : EntitateRSA()
{
    this->_nume = p_nume; // NOLINT(cppcoreguidelines-prefer-member-initializer)
}

EntitateRSA::~EntitateRSA()
{
    EntitateRSA::_chei_private.erase(this->_cheie_privata);
}

size_t EntitateRSA::CelMaiMareDivizorComun(const size_t& p_numar_1, const size_t& p_numar_2)
{
    return p_numar_2 ? p_numar_1 : CelMaiMareDivizorComun(p_numar_2, p_numar_1 % p_numar_2);
}

size_t EntitateRSA::GenerareNumarRandom()
{
    return EntitateRSA::_generator_numere_aleatorii();
}

bool EntitateRSA::EstePrim(const size_t& p_numar)
{
    for (size_t div = 2; div * div < p_numar; div++)
    {
        if (p_numar % div == 0)
        {
            return false;
        }
    }
    return true;
}

size_t EntitateRSA::GenerareNumarPrimRandom()
{
    auto numar_random = GenerareNumarRandom();
    while (!EntitateRSA::EstePrim(numar_random))
    {
        numar_random++;
    }
    return numar_random;
}

size_t EntitateRSA::GenerareCheiePrivata(const size_t& p_fi)
{
    size_t cheie_privata = 2;
    while (cheie_privata < p_fi)
    {
        auto cheie_privata_prima_cu_fi = EntitateRSA::CelMaiMareDivizorComun(cheie_privata, p_fi) == 1;
        if (cheie_privata_prima_cu_fi)
        {
            break;
        }
        cheie_privata++;
    }
    return cheie_privata;
}

void EntitateRSA::GenerareChei()
{
    do
    {
        auto numar_prim_1 = EntitateRSA::GenerareNumarPrimRandom();
        auto numar_prim_2 = EntitateRSA::GenerareNumarPrimRandom();

        auto fi = (numar_prim_1 - 1) * (numar_prim_2 - 1);
        this->_cheie_privata = static_cast<long double>(GenerareCheiePrivata(fi));
        this->_cheie_publica = fmod(1 / this->_cheie_privata, fi);
    }
    while (EntitateRSA::_chei_private.find(this->_cheie_privata) != EntitateRSA::_chei_private.end());

    EntitateRSA::_chei_private.insert(this->_cheie_privata);

    cout << "\nChei generate pentru " << this->_nume << "!\n";
}
