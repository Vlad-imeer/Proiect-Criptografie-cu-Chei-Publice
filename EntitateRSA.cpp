#include "EntitateRSA.h"

const string EntitateRSA::NEDEFINIT = "NEDEFINIT";
const size_t EntitateRSA::LIMITA_NUMAR_ALEATOR = 5;

unordered_set<long double> EntitateRSA::_chei_private = {};

// ”
// This compliant solution uses std::random_device to generate a random value for seeding the Mersenne Twister engine object.
// The values generated by std::random_device are nondeterministic random numbers when possible, relying on random number generation devices, such as /dev/random.
// When such a device is not available, std::random_device may employ a random number engine; however, the initial value generated should have sufficient randomness to serve as a seed value.
// ”
// Sursă: https://wiki.sei.cmu.edu/confluence/display/cplusplus/MSC51-CPP.+Ensure+your+random+number+generator+is+properly+seeded
random_device EntitateRSA::_generator_seed = {};
mt19937 EntitateRSA::_generator_numere_aleatorii(EntitateRSA::_generator_seed());

size_t EntitateRSA::CelMaiMareDivizorComun(const size_t& p_numar_1, const size_t& p_numar_2)
{
    return p_numar_2 ? p_numar_1 : CelMaiMareDivizorComun(p_numar_2, p_numar_1 % p_numar_2);
}

size_t EntitateRSA::GenerareNumarRandom()
{
    return EntitateRSA::_generator_numere_aleatorii() % LIMITA_NUMAR_ALEATOR;
}

bool EntitateRSA::EstePrim(const size_t& p_numar)
{
    for (size_t div = 2; div * div < p_numar; div++)
    {
        if (p_numar % div == 0)
        {
            return false;
        }
    }
    return true;
}

size_t EntitateRSA::GenerareNumarPrimRandom()
{
    auto numar_random = GenerareNumarRandom();
    while (!EntitateRSA::EstePrim(numar_random))
    {
        numar_random++;
    }
    return numar_random;
}

size_t EntitateRSA::GenerareCheiePrivata(const size_t& p_fi)
{
    size_t cheie_privata = 2;
    while (cheie_privata < p_fi)
    {
        auto cheie_privata_prima_cu_fi = EntitateRSA::CelMaiMareDivizorComun(cheie_privata, p_fi) == 1;
        if (cheie_privata_prima_cu_fi)
        {
            break;
        }
        cheie_privata++;
    }
    return cheie_privata;
}

long double EntitateRSA::GetCheieFolosita(const TipCheie& p_tip_cheie) const
{
    switch (p_tip_cheie)
    {
    case EntitateRSA::TipCheie::Privata:
        return this->_cheie_privata;
    case EntitateRSA::TipCheie::Publica:
        return this->_cheie_publica;
    }
    throw logic_error("Tipul de cheie " + to_string(p_tip_cheie) + " neimplementat");
}

long double EntitateRSA::Encriptare(const long double& p_mesaj, const TipCheie& p_tip_cheie) const
{
    auto cheie_folosita = GetCheieFolosita(p_tip_cheie);
    auto mesaj_encriptat = pow(p_mesaj, cheie_folosita);
    mesaj_encriptat = fmod(mesaj_encriptat, this->_produs_numere_prime);
    return mesaj_encriptat;
}

long double EntitateRSA::Decriptare(const long double& p_mesaj, const TipCheie&) const
{
    return 0;
}

EntitateRSA::EntitateRSA() : _cheie_privata(0), _cheie_publica(0), _produs_numere_prime(0), _nume(EntitateRSA::NEDEFINIT)
{
}

EntitateRSA::EntitateRSA(const string& p_nume) : EntitateRSA()
{
    this->_nume = p_nume; // NOLINT(cppcoreguidelines-prefer-member-initializer)
}

EntitateRSA::~EntitateRSA()
{
    EntitateRSA::_chei_private.erase(this->_cheie_privata);
}

void EntitateRSA::GenerareChei()
{
    do
    {
        auto numar_prim_1 = EntitateRSA::GenerareNumarPrimRandom();
        auto numar_prim_2 = EntitateRSA::GenerareNumarPrimRandom();
        this->_produs_numere_prime = numar_prim_1 * numar_prim_2;

        auto fi = (numar_prim_1 - 1) * (numar_prim_2 - 1);
        this->_cheie_privata = static_cast<long double>(GenerareCheiePrivata(fi));
        this->_cheie_publica = fmod(1 / this->_cheie_privata, fi);
    }
    while (EntitateRSA::_chei_private.find(this->_cheie_privata) != EntitateRSA::_chei_private.end());

    EntitateRSA::_chei_private.insert(this->_cheie_privata);

    cout << "\nChei generate pentru " << this->_nume << "!";
}

long double EntitateRSA::EncriptareCuCheiePrivata(const long double& p_mesaj) const
{
    return this->Encriptare(p_mesaj, EntitateRSA::TipCheie::Publica);
}

long double EntitateRSA::EncriptareCuCheiePublica(const long double& p_mesaj) const
{
    return this->Encriptare(p_mesaj, EntitateRSA::TipCheie::Publica);
}

long double EntitateRSA::DecriptareCuCheiePrivata(const long double& p_mesaj) const
{
    return this->Decriptare(p_mesaj, EntitateRSA::TipCheie::Privata);
}

long double EntitateRSA::DecriptareCuCheiePublica(const long double& p_mesaj) const
{
    return this->Decriptare(p_mesaj, EntitateRSA::TipCheie::Publica);
}

ostream& operator<<(ostream& p_stream, const EntitateRSA& p_entitate)
{
    p_stream << p_entitate._nume;
    return p_stream;
}
